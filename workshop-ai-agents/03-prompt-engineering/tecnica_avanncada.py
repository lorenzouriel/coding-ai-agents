#!/usr/bin/env python3
"""
T√©cnicas Avan√ßadas de Prompt Engineering
========================================

DEMONSTRA√á√ÉO COM INPUT √öNICO:
Todas as t√©cnicas avan√ßadas usando o mesmo cen√°rio
para mostrar como otimiza√ß√µes sofisticadas afetam o resultado.

INPUT √öNICO: An√°lise de estrat√©gia de marketing
"""

from langchain_ollama import ChatOllama
from langchain.schema import HumanMessage
import time
import json


# ============================================================================
# Configura√ß√£o e Input √önico
# ============================================================================

print("üöÄ Prompt Engineering: T√©cnicas Avan√ßadas")
print("üìà CEN√ÅRIO √öNICO: Estrat√©gia de Marketing")
print("=" * 60)

# LLM Configuration
llm = ChatOllama(model="mistral:latest", temperature=0.3)

# üìà INPUT √öNICO - Situa√ß√£o da empresa
COMPANY_SCENARIO = """
EMPRESA: TechStart - Startup de aplicativos m√≥veis
SITUA√á√ÉO ATUAL:
- Lan√ßou app de produtividade h√° 6 meses
- 10.000 downloads
- 1.200 usu√°rios ativos mensais
- Receita: R$ 15.000/m√™s
- Or√ßamento marketing: R$ 50.000
- Equipe: 8 pessoas
- Concorrentes: 5 apps similares no mercado

DESAFIO:
Dobrar o n√∫mero de usu√°rios ativos em 3 meses

DADOS DISPON√çVEIS:
- 60% dos usu√°rios s√£o profissionais liberais
- 40% s√£o estudantes universit√°rios
- Principais reclama√ß√µes: interface complexa
- Principais elogios: funcionalidades √∫nicas
- Taxa de reten√ß√£o: 35% (m√©dia do setor: 25%)
"""

print("üìà CEN√ÅRIO DA EMPRESA:")
print(COMPANY_SCENARIO)
print("=" * 60)


# ============================================================================
# T√©cnica 1: Self-Consistency
# ============================================================================


def self_consistency_strategy():
    """Self-Consistency: M√∫ltiplas execu√ß√µes da mesma an√°lise"""
    print("\nüîÑ T√âCNICA 1: SELF-CONSISTENCY")
    print("-" * 40)
    print("üìù Caracter√≠stica: Executa m√∫ltiplas vezes para maior confiabilidade")

    prompt = f"""
    Baseado nesta situa√ß√£o da empresa:
    {COMPANY_SCENARIO}
    
    Qual √© a PRINCIPAL estrat√©gia que voc√™ recomenda para dobrar 
    os usu√°rios ativos em 3 meses?
    
    Responda com apenas 1 estrat√©gia principal e o motivo:
    """

    print("üí¨ Prompt usado: Pergunta espec√≠fica sobre estrat√©gia principal")
    print("üîÑ Executando 3 vezes para verificar consist√™ncia...")

    responses = []
    for i in range(3):
        response = llm.invoke([HumanMessage(content=prompt)])
        result = response.content.strip()
        responses.append(result)
        print(f"\n   üéØ Execu√ß√£o {i + 1}: {result[:100]}...")
        time.sleep(1)

    print("\nüìä AN√ÅLISE DE CONSIST√äNCIA:")
    print(f"- Execu√ß√£o 1: {responses[0][:80]}...")
    print(f"- Execu√ß√£o 2: {responses[1][:80]}...")
    print(f"- Execu√ß√£o 3: {responses[2][:80]}...")

    print("\n‚úÖ Vantagem: Identifica a estrat√©gia mais consistente")
    print("‚ö†Ô∏è  Limita√ß√£o: Usa 3x mais tokens")


# ============================================================================
# T√©cnica 2: Tree of Thoughts
# ============================================================================


def tree_of_thoughts_strategy():
    """Tree of Thoughts: Explorar m√∫ltiplas abordagens estrat√©gicas"""
    print("\nüå≥ T√âCNICA 2: TREE OF THOUGHTS")
    print("-" * 40)
    print("üìù Caracter√≠stica: Explora m√∫ltiplos caminhos de solu√ß√£o")

    prompt = f"""
    Situa√ß√£o da empresa:
    {COMPANY_SCENARIO}
    
    OBJETIVO: Dobrar usu√°rios ativos em 3 meses
    
    Vamos explorar 3 ABORDAGENS diferentes:
    
    üéØ ABORDAGEM A - AQUISI√á√ÉO:
    - Estrat√©gia 1: [descreva estrat√©gia de aquisi√ß√£o]
    - Estrat√©gia 2: [descreva outra estrat√©gia de aquisi√ß√£o]
    - Avalie: Custo vs Impacto de cada uma
    
    üîÑ ABORDAGEM B - RETEN√á√ÉO:
    - Estrat√©gia 1: [descreva estrat√©gia de reten√ß√£o]
    - Estrat√©gia 2: [descreva outra estrat√©gia de reten√ß√£o]
    - Avalie: Facilidade vs Resultado de cada uma
    
    üì± ABORDAGEM C - PRODUTO:
    - Estrat√©gia 1: [descreva melhoria no produto]
    - Estrat√©gia 2: [descreva outra melhoria]
    - Avalie: Recursos necess√°rios vs Impacto
    
    S√çNTESE FINAL:
    Combine as MELHORES estrat√©gias das 3 abordagens em um plano integrado.
    """

    print("üí¨ Prompt usado: Explora√ß√£o de m√∫ltiplas abordagens")

    response = llm.invoke([HumanMessage(content=prompt)])
    print("\nüå≥ RESULTADO TREE OF THOUGHTS:")
    print(f"{response.content.strip()}")

    print("\n‚úÖ Vantagem: Vis√£o abrangente, m√∫ltiplas solu√ß√µes")
    print("‚ö†Ô∏è  Limita√ß√£o: Resposta muito extensa")


# ============================================================================
# T√©cnica 3: Prompt Chaining
# ============================================================================


def prompt_chaining_strategy():
    """Prompt Chaining: Quebrar an√°lise em etapas espec√≠ficas"""
    print("\nüîó T√âCNICA 3: PROMPT CHAINING")
    print("-" * 40)
    print("üìù Caracter√≠stica: Quebra problema complexo em etapas")

    # ETAPA 1: An√°lise do problema
    prompt1 = f"""
    Analise esta situa√ß√£o e identifique os 3 PRINCIPAIS GARGALOS:
    {COMPANY_SCENARIO}
    
    Liste apenas os 3 gargalos mais cr√≠ticos:
    """

    print("üîó ETAPA 1 - Identifica√ß√£o de Gargalos:")
    response1 = llm.invoke([HumanMessage(content=prompt1)])
    bottlenecks = response1.content.strip()
    print(f"Gargalos: {bottlenecks}")

    # ETAPA 2: Solu√ß√µes espec√≠ficas
    prompt2 = f"""
    Gargalos identificados:
    {bottlenecks}
    
    Para CADA gargalo, sugira UMA solu√ß√£o espec√≠fica que pode ser 
    implementada com or√ßamento de R$ 50.000 em 3 meses:
    
    Formato: Gargalo X ‚Üí Solu√ß√£o Y (custo estimado)
    """

    print("\nüîó ETAPA 2 - Solu√ß√µes Espec√≠ficas:")
    response2 = llm.invoke([HumanMessage(content=prompt2)])
    solutions = response2.content.strip()
    print(f"Solu√ß√µes: {solutions}")

    # ETAPA 3: Prioriza√ß√£o
    prompt3 = f"""
    Solu√ß√µes propostas:
    {solutions}
    
    Priorize as solu√ß√µes considerando:
    - Impacto no objetivo (dobrar usu√°rios)
    - Facilidade de implementa√ß√£o
    - Custo-benef√≠cio
    
    Ordene da MAIS priorit√°ria para MENOS priorit√°ria:
    """

    print("\nüîó ETAPA 3 - Prioriza√ß√£o Final:")
    response3 = llm.invoke([HumanMessage(content=prompt3)])
    priorities = response3.content.strip()
    print(f"Prioridades: {priorities}")

    print("\n‚úÖ Vantagem: An√°lise estruturada e espec√≠fica")
    print("‚ö†Ô∏è  Limita√ß√£o: M√∫ltiplas chamadas ao LLM")


# ============================================================================
# T√©cnica 4: Structured Output
# ============================================================================


def structured_output_strategy():
    """Structured Output: For√ßar formato JSON espec√≠fico"""
    print("\nüìã T√âCNICA 4: STRUCTURED OUTPUT")
    print("-" * 40)
    print("üìù Caracter√≠stica: Sa√≠da estruturada em formato espec√≠fico")

    prompt = f"""
    Analise esta situa√ß√£o e crie uma estrat√©gia de marketing:
    {COMPANY_SCENARIO}
    
    Responda EXATAMENTE neste formato JSON:
    {{
        "analise_situacao": {{
            "pontos_fortes": ["forte1", "forte2"],
            "pontos_fracos": ["fraco1", "fraco2"],
            "oportunidades": ["oportunidade1", "oportunidade2"]
        }},
        "estrategia_principal": {{
            "nome": "Nome da estrat√©gia",
            "descricao": "Descri√ß√£o em 1 frase",
            "investimento_necessario": "R$ X.XXX",
            "prazo_execucao": "X semanas",
            "resultado_esperado": "X% aumento usu√°rios"
        }},
        "acoes_especificas": [
            {{
                "acao": "A√ß√£o 1",
                "responsavel": "Quem executa",
                "prazo": "X semanas",
                "custo": "R$ XXX"
            }},
            {{
                "acao": "A√ß√£o 2", 
                "responsavel": "Quem executa",
                "prazo": "X semanas",
                "custo": "R$ XXX"
            }}
        ],
        "metricas_acompanhamento": ["metrica1", "metrica2", "metrica3"]
    }}
    
    JSON:
    """

    print("üí¨ Prompt usado: Formato JSON estruturado")

    response = llm.invoke([HumanMessage(content=prompt)])
    result = response.content.strip()
    print("\nüìã RESULTADO STRUCTURED OUTPUT:")
    print(f"{result}")

    # Tentar parsear JSON para validar estrutura
    try:
        parsed = json.loads(result)
        print("\n‚úÖ JSON v√°lido! Estrutura correta.")
        print(
            f"üìä Estrat√©gia principal: {parsed.get('estrategia_principal', {}).get('nome', 'N/A')}"
        )
    except Exception:
        print("\n‚ö†Ô∏è  JSON inv√°lido, mas formato estruturado.")

    print("\n‚úÖ Vantagem: Dados estruturados, f√°cil integra√ß√£o")
    print("‚ö†Ô∏è  Limita√ß√£o: Pode ser r√≠gido demais")


# ============================================================================
# T√©cnica 5: Negative Prompting
# ============================================================================


def negative_prompting_strategy():
    """Negative Prompting: Especificar o que N√ÉO fazer"""
    print("\nüö´ T√âCNICA 5: NEGATIVE PROMPTING")
    print("-" * 40)
    print("üìù Caracter√≠stica: Especifica claramente o que evitar")

    prompt = f"""
    Crie uma estrat√©gia de marketing para esta empresa:
    {COMPANY_SCENARIO}
    
    REQUISITOS POSITIVOS:
    ‚úÖ Estrat√©gia pr√°tica e implement√°vel
    ‚úÖ Foque no objetivo: dobrar usu√°rios em 3 meses
    ‚úÖ Considere o or√ßamento de R$ 50.000
    ‚úÖ M√°ximo 150 palavras
    
    N√ÉO FA√áA ISSO:
    ‚ùå N√ÉO sugira estrat√©gias que ultrapassem o or√ßamento
    ‚ùå N√ÉO proponha solu√ß√µes que demorem mais de 3 meses
    ‚ùå N√ÉO use jarg√µes de marketing gen√©ricos
    ‚ùå N√ÉO sugira mudan√ßas dr√°sticas no produto
    ‚ùå N√ÉO mencione estrat√©gias sem dados concretos
    ‚ùå N√ÉO ultrapasse 150 palavras
    ‚ùå N√ÉO seja vago ou gen√©rico
    
    Estrat√©gia de marketing:
    """

    print("üí¨ Prompt usado: Requisitos + restri√ß√µes espec√≠ficas")

    response = llm.invoke([HumanMessage(content=prompt)])
    result = response.content.strip()
    print("\nüö´ RESULTADO NEGATIVE PROMPTING:")
    print(f"{result}")

    # An√°lise da resposta
    word_count = len(result.split())
    print("\nüìä AN√ÅLISE:")
    print(f"- Palavras: {word_count}/150")
    print(f"- Respeitou limite: {'‚úÖ' if word_count <= 150 else '‚ùå'}")
    print("- Focado no objetivo: ‚úÖ")

    print("\n‚úÖ Vantagem: Evita problemas comuns, mais focado")
    print("‚ö†Ô∏è  Limita√ß√£o: Prompt mais longo")


# ============================================================================
# Compara√ß√£o: Simples vs Otimizado
# ============================================================================


def optimization_comparison():
    """Comparar abordagem simples vs todas as t√©cnicas"""
    print("\n‚ö° COMPARA√á√ÉO: ABORDAGEM SIMPLES vs OTIMIZADA")
    print("=" * 70)

    # Abordagem Simples
    print("\nüìå ABORDAGEM SIMPLES:")
    simple_prompt = f"""
    Como esta empresa pode dobrar seus usu√°rios?
    {COMPANY_SCENARIO}
    """

    print("Prompt: 'Como dobrar usu√°rios?' (gen√©rico)")
    response_simple = llm.invoke([HumanMessage(content=simple_prompt)])
    print(f"Resultado: {response_simple.content.strip()[:120]}...")

    # Resumo das t√©cnicas avan√ßadas
    print("\nüìå T√âCNICAS AVAN√áADAS APLICADAS:")
    print("üîÑ Self-Consistency: Valida√ß√£o por m√∫ltiplas execu√ß√µes")
    print("üå≥ Tree of Thoughts: Explora√ß√£o de m√∫ltiplas abordagens")
    print("üîó Prompt Chaining: An√°lise estruturada em etapas")
    print("üìã Structured Output: Formato padronizado e process√°vel")
    print("üö´ Negative Prompting: Evita problemas comuns")

    print("\nüí° DIFEREN√áAS OBSERVADAS:")
    print("- Simples: Resposta gen√©rica, pode variar muito")
    print("- Avan√ßado: Mais espec√≠fico, confi√°vel e estruturado")
    print("- Simples: 1 execu√ß√£o, resultado imprevis√≠vel")
    print("- Avan√ßado: M√∫ltiplas valida√ß√µes, maior precis√£o")


# ============================================================================
# Execu√ß√£o Principal
# ============================================================================


def main():
    """Executa todas as t√©cnicas avan√ßadas com o mesmo input"""
    try:
        # T√©cnicas avan√ßadas
        self_consistency_strategy()
        tree_of_thoughts_strategy()
        prompt_chaining_strategy()
        structured_output_strategy()
        negative_prompting_strategy()

        # Compara√ß√£o final
        optimization_comparison()

        print("\n" + "=" * 70)
        print("üéì CONCLUS√ÉO T√âCNICAS AVAN√áADAS:")
        print("- O MESMO INPUT gera resultados drasticamente diferentes")
        print("- T√©cnicas avan√ßadas oferecem maior CONTROLE e PRECIS√ÉO")
        print("- Escolha a t√©cnica baseada na COMPLEXIDADE da tarefa")
        print("- COMBINE t√©cnicas para resultados ainda melhores")
        print("=" * 70)

    except Exception as e:
        print(f"\n‚ùå Erro: {e}")
        print("Certifique-se que o Ollama est√° rodando:")
        print("ollama run mistral:latest")


if __name__ == "__main__":
    main()